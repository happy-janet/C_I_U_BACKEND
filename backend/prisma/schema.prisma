generator client {
  provider = "prisma-client-js"
}



datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


model LecturerSignUp {
  id               Int       @id @default(autoincrement())
  first_name       String
  last_name        String
  email            String    @unique
  role             String
  token            String?
  tokenExpiry      DateTime?
  password         String?
  resetToken       String?   @unique
  resetTokenExpiry DateTime?
}

model AdminSignUp {
  id               Int       @id @default(autoincrement())
  first_name       String
  last_name        String
  email            String    @unique
  role             String
  password         String?
  resetToken       String?   @unique
  resetTokenExpiry DateTime?
}

model users {
  id               Int            @id @default(autoincrement())
  first_name       String
  last_name        String
  email            String         @unique
  program          String
  createdAt        DateTime       @default(now())
  lastLogin        DateTime?
  registrationNo   String         @unique
  password         String
  role             String
  resetToken       String?        @unique
  resetTokenExpiry DateTime?
  courseId         Int
  issueReports     IssueReport[]  @relation("StudentReports")
  submissions      Submission[]
  course           courses        @relation(fields: [courseId], references: [id])
  courses          courses[]      @relation("UserCourses")
  scores           Score[]        @relation("StudentScores")
  notifications    Notification[] // Relation to Notification model
  loginHistory     LoginHistory[] @relation("StudentLoginHistory") // Corrected relation field
  examProgress     ExamProgress[] @relation("UserExamProgress")
}

model IssueReport {
  id               Int      @id @default(autoincrement())
  issueDescription String
  regno            String
  reportedAt       DateTime @default(now())
  studentId        Int
  student          users    @relation("StudentReports", fields: [studentId], references: [id])
}



model FAQ {
  id       Int    @id @default(autoincrement())
  question String
  answer   String
}


model Submission {
  id           Int              @id @default(autoincrement())
  studentId    Int
  assessmentId Int
  answers      Json
  score        Int
  percentage   Float
  submittedAt  DateTime
  assessment   ManualAssessment @relation(fields: [assessmentId], references: [id])
  student      users            @relation(fields: [studentId], references: [id])
}


model Score {
  id               Int               @id @default(autoincrement())
  score            Int
  percentage       Float
  userId           Int
  addAssessmentId  Int?              // New field for addAssessment
  manualAssessmentId Int?            // New field for manualAssessment
  student          users             @relation(fields: [userId], references: [id], name: "StudentScores")
  addAssessment    addAssessment?    @relation(fields: [addAssessmentId], references: [id], name: "AssessmentScores", map: "Score_addAssessmentId_assessment_fkey")
  manualAssessment ManualAssessment? @relation(fields: [manualAssessmentId], references: [id], name: "ManualAssessmentScores", map: "Score_manualAssessmentId_manual_fkey")
  @@unique([addAssessmentId, userId]) // Prevent duplicate addAssessment scores per user
  @@unique([manualAssessmentId, userId]) // Prevent duplicate manualAssessment scores per user
}

model courses {
  id                Int                @id @default(autoincrement())
  facultyName       String
  courseName        String
  courseUnits       String[]
  courseUnitCode    String[]
  manualAssessments ManualAssessment[]
  addAssessments    addAssessment[]
  users             users[]
  students          users[]            @relation("UserCourses")
}

model LoginHistory {
  id         Int      @id @default(autoincrement())
  studentId  Int
  loginTime  DateTime @default(now())
  ipAddress  String?
  // Relation to the `users` model
  student users @relation("StudentLoginHistory", fields: [studentId], references: [id])
}

model addAssessment {
  id             Int            @id @default(autoincrement())
  title          String
  description    String
  courseId       Int
  courseUnit     String
  courseUnitCode String
  duration       String
  scheduledDate  DateTime
  startTime      DateTime
  endTime        DateTime
  createdBy      String
  createdAt      DateTime       @default(now())
  status         String         @default("draft")
  isDraft        Boolean        @default(true)
  questions      Question[]     @relation("AssessmentQuestions")
  course         courses        @relation(fields: [courseId], references: [id])
  isPublished       Boolean    @default(false)
  scores         Score[]        @relation("AssessmentScores")
  questionBanks  QuestionBank[]
  examProgress   ExamProgress[] @relation("AddAssessmentProgress")
}


model Question {
  id             Int            @id @default(autoincrement())
  questionNumber Int
  content        String
  answer         String?
  options        Json
  assessmentId   Int
  assessment     addAssessment  @relation("AssessmentQuestions", fields: [assessmentId], references: [id])
  questionBanks  QuestionBank[] // Many-to-many relationship with question banks
}


model ManualAssessment {
  id             Int              @id @default(autoincrement())
  title          String
  description    String
  courseId       Int
  courseUnit     String
  courseUnitCode String
  duration       String
  scheduledDate  DateTime
  startTime      DateTime
  endTime        DateTime
  createdBy      String
  createdAt      DateTime         @default(now())
  status         String           @default("draft")
  isDraft        Boolean          @default(true)
  course         courses          @relation(fields: [courseId], references: [id])
  questions      QuestionManual[]
  submissions    Submission[]
  // Relationship with Score
  scores         Score[]          @relation("ManualAssessmentScores")
  examProgress   ExamProgress[]   @relation("ManualAssessmentProgress")
}



model QuestionManual {
  id           Int              @id @default(autoincrement())
  content      String
  answer       String?
  options      Json
  assessmentId Int
  assessment   ManualAssessment @relation(fields: [assessmentId], references: [id])
}



model ExamProgress {
  id                 Int      @id @default(autoincrement())
  studentId          Int
  addAssessmentId    Int? // Nullable for ManualAssessment progress
  manualAssessmentId Int? // Nullable for AddAssessment progress
  examId             Int      // Add examId field here (if required)
  currentQuestion    Int      @default(1) // Default to the first question
  answers            Json?
  timeSpent          Int      @default(0) // Time in seconds or minutes
  isCompleted        Boolean  @default(false) // Track exam completion status
  status             String   @default("in-progress") // Add status field
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Relation to the `users` model (student)
  student            users   @relation(fields: [studentId], references: [id], name: "UserExamProgress")

  // Relation to the `addAssessment` model
  addAssessment      addAssessment? @relation(fields: [addAssessmentId], references: [id], name: "AddAssessmentProgress")
  // Relation to the `ManualAssessment` model
  manualAssessment   ManualAssessment? @relation(fields: [manualAssessmentId], references: [id], name: "ManualAssessmentProgress")

  // Ensure each student can have only one progress entry per assessment type
  @@unique([studentId, addAssessmentId])
  @@unique([studentId, manualAssessmentId])
  @@unique([studentId, examId]) // Add a unique constraint for studentId and examId if needed
}


model QuestionBank {
  id             Int           @id @default(autoincrement())
  courseUnit     String
  courseUnitCode String
  assessment     addAssessment @relation(fields: [assessmentId], references: [id])
  assessmentId   Int
  questions      Question[] // Many-to-many relationship with questions
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
}



model Notification {
  id        Int      @id @default(autoincrement())
  userId    Int
  title     String
  message   String
  eventType String
  read      Boolean  @default(false)
  createdAt DateTime @default(now())
  user      users @relation(fields: [userId], references: [id])
}
